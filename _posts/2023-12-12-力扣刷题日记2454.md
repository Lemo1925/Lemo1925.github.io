---
layout: post
title: "2454. 下一个更大元素 IV"
date: 2023-12-12
tag: leetcodes
---

# [题目](https://leetcode.cn/problems/next-greater-element-iv/) 

给你一个下标从 **0** 开始的非负整数数组 `nums` 。对于 `nums` 中每一个整数，你必须找到对应元素的 **第二大** 整数。

如果 `nums[j]` 满足以下条件，那么我们称它为 `nums[i]` 的 **第二大** 整数：

- `j > i`
- `nums[j] > nums[i]`
- 恰好存在 **一个** `k` 满足 `i < k < j` 且 `nums[k] > nums[i]` 。

如果不存在 `nums[j]` ，那么第二大整数为 `-1` 。

- 比方说，数组 `[1, 2, 4, 3]` 中，`1` 的第二大整数是 `4` ，`2` 的第二大整数是 `3` ，`3` 和 `4` 的第二大整数是 `-1` 。

请你返回一个整数数组 `answer` ，其中 `answer[i]`是 `nums[i]` 的第二大整数。

 

**示例 1：**

```
输入：nums = [2,4,0,9,6]
输出：[9,6,6,-1,-1]
解释：
下标为 0 处：2 的右边，4 是大于 2 的第一个整数，9 是第二个大于 2 的整数。
下标为 1 处：4 的右边，9 是大于 4 的第一个整数，6 是第二个大于 4 的整数。
下标为 2 处：0 的右边，9 是大于 0 的第一个整数，6 是第二个大于 0 的整数。
下标为 3 处：右边不存在大于 9 的整数，所以第二大整数为 -1 。
下标为 4 处：右边不存在大于 6 的整数，所以第二大整数为 -1 。
所以我们返回 [9,6,6,-1,-1] 。
```

**示例 2：**

```
输入：nums = [3,3]
输出：[-1,-1]
解释：
由于每个数右边都没有更大的数，所以我们返回 [-1,-1] 。
```

 

**提示：**

- `1 <= nums.length <= 10^5`
- `0 <= nums[i] <= 10^9`



# 思路

## 最初的想法

* 用一个`res`数组存储答案，并将其初始化为`-1`;
* 拿一个栈去存储比当前元素大的值；
* 当栈内元素为`2`的时候，将`res`的对应位置赋值为当前值，然后清空栈内元素；
* 当遍历结束时，`res`就是答案。
* 此方法时间复杂度过大

## 正确思路

|  i   | nums[i] |   t   |   s   |       res        |
| :--: | :-----: | :---: | :---: | :--------------: |
|  0   |    2    |  [2]  |  []   | [-1,-1,-1,-1,-1] |
|  1   |    4    |  [4]  |  [2]  | [-1,-1,-1,-1,-1] |
|  2   |    0    | [4,0] |  [2]  | [-1,-1,-1,-1,-1] |
|  3   |    9    |  [9]  | [4,0] | [9,-1,-1,-1,-1]  |
|  4   |    6    | [9,6] |  []   |  [9,6,6,-1,-1]   |



* 初始化 `res` 数组，长度和 `nums` 相同，初始值均为 `-1`。
* 初始化两个空栈 `s` 和 `t`。
* 从左到右遍历 `nums`。
* 设 `v=nums[i]`。如果 `x` 比 `s` 的栈顶大，则栈顶元素对应的答案为 `v`，并弹出 `s` 的栈顶。
* 如果 `v` 比 `t` 的栈顶大，则弹出 `t`的栈顶，并移入 `s` 的栈顶。由于要保证 `s` 也是一个递减的单调栈，我们可以直接把一整段从 `t` 中弹出的元素插入到 `s` 的末尾。
* 把 `v` 加到 `t` 的栈顶。代码实现时，为方便记录答案，改为把 `v` 的下标 `i` 加到栈顶。



# 题解

## 最初解法

```c++
vector<int> secondGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, -1);    
    for (int i = 0; i < n - 2; i++)
    {
        stack<int> s;
        for (int j = i + 1; j < n; j++)
        {
            int v = nums[j];
            if (v > nums[i]) s.push(v);
            if (s.size() == 2){
                res[i] = s.top();
                s.pop(); s.pop();
                break;
            }
        }
    }
    return res;
}
```



## 正解

```c++
vector<int> secondGreaterElement(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n, -1);    
    vector<int> s, t;
    for (int i = 0; i < n ; i++)
    {
        int v = nums[i];
        while(!s.empty() && nums[s.back()] < v){
            res[s.back()] = v;
            s.pop_back();
        }
        int pos = t.size() - 1;
        // 小于v的整一段元素
        while (pos >= 0 && nums[t[pos]] < v)
        {
            --pos;
        }
        s.insert(s.end(), t.begin() + (pos + 1), t.end());
        t.resize(pos + 1);
        t.push_back(i);
    }
    return res;
}
```

